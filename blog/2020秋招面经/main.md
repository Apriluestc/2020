* [什么是 SQL 注入？如何预防 SQL 注入？](#什么是-sql-注入如何预防-sql-注入)
* [fork 和 vfork](#fork-和-vfork)
* [Web 请求页面的全过程](#web-请求页面的全过程)

### 什么是 SQL 注入？如何预防 SQL 注入？

**什么是 SQL 注入**

所谓 SQL 注入式攻击，就是攻击者把 SQL 命令插入到 Web 表单的输入域或页面请求的查询字符串，欺骗服务器恶意执行 SQL 命令，**具
体来说，它就是利用现有程序，将恶意的 SQL 命令注入到后台数据库引擎上的能力，它可以通过在 Web 表单中输入恶意 SQL 语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行 SQL 语句**

**如何防范 SQL 注入(针对 JSP)**

在利用表单输入的内容构造 SQL 命令之前，把所有输入内容过滤一番就可以了

- 使用正则表达式过滤传入的参数
- 字符串过滤
- JSP 中调用该函数检查是否包含非法字符
- JSP 页面判断代码

凡涉及到执行的 SQL 语句中有变量时，用 JDBC 提供的 PreparedStatement 就可以，切记不要用拼接字符串的方法就可以了

### fork 和 vfork

fork 和 vfork 都是创建一个进程，但是有一下区别

- fork 子进程拷贝父进程的数据段、代码段，vfork 子进程和父进程则共享数据段
- fork 父子进程执行次序不确定，vfork 保证子进程先运行，在调用 exec 或 exit 之前与父进程数据是共享的，在它调用 exec 或 exit 之后父进程才可能被调度运行
- vfork 保证子进程先运行，在它调用 exec 或 exit 之后父进程才可能被调度运行，如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁

进程创建 fork，此奇妙之处在于它被调用一次，却返回两次，它可能有三种不同的返回值

- 在父进程中，fork 返回新创建的子进程的 PID
- 在子进程中，fork 返回 0
- 如果出现错误，fork 返回一个负值

**操作系统创建进程的步骤**

- 申请新的 PCB
- 为新进程分配资源
- 初始化 PCB
- 将新进程插入到就绪队列中

**fork 调用底层**

- fork、vfork、_clone -> clone -> do_fork -> copy_process ->
  - dup_task_struct 为新进程创建与父进程值相同的内核栈，thread_info 和 task_struct，此时父子进程描述符相同
  - check 当前用户拥有进程数未超过给它分配的资源限制
  - 区别父子进程描述符，部分进程描述符成员清零或设置
  - set 子进程 state 为 TASK_UNINTERRUPTIBLE
  - copy_flags 更新 task_struct 中的 flags，进程是否拥有超级用户权限清零，进程还没调用 exec 函数表示设置
  - alloc_pid 为新进程分配有效的 PID
  - 根据 clone 参数，copy_process 拷贝或共享打开的文件，进程地址空间等
  - copy_process 扫尾并返回指向子进程的指针

### Web 请求页面的全过程

输入地址->域名解析->浏览器向服务器发起 HTTP 请求->服务器处理 HTTP 请求->浏览器处理并显示 html

- 浏览器查找域名对应的 IP 地址(DNS 协议)

  - 请求一旦发起，浏览器首先要做的就是解析这个域名，一般来说，浏览器会首先查看本地的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的化就直接使用 hosts 文件里面的 IP 地址
  - 如果本地的 hosts 文件中未命中，浏览器会发出一个 DNS 请求到本地 DNS服务器
  - 查询你输入网址的 DNS 请求到达本地 DNS 服务器后，本地 DNS 服务器会首先查询它的缓存记录，如果缓存中有此记录，就可以直接返回结果，此过程是递归的方式进行查询，如果没有，本地 DNS 服务器还要向根域名服务器进行查询
  - 根域名服务器没有记录具体的域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你可以去上级域名服务器上查询，并给出域名服务器的地址，这种是迭代的过程
  - 本地 DNS 服务器继续向域名服务器发出请求，在这个例子中，请求的对象是 .com 域名服务器，.com 服务器收到请求后，也不会返回域名和 IP 地址的映射关系，而是告诉本地 DNS 服务器，你的域名解析服务器的地址
  - 最后，本地 DNS 服务器向域名的域名解析服务器发出请求，这时就会收到一个域名和 IP 地址的映射关系，本地 DNS 服务器不仅要把 IP 地址返回给用户电脑，还要把这个映射关系保存在缓存中，以备下次访问时，直接返回结果，加快网络访问

- 浏览器携带 IP 向服务器发器 HTTP 请求

拿到域名对应的 IP 地址之后，浏览器会一个随即端口向服务器 80 端口发起 TCP 连接请求，这个连接请求达到服务器端后(通过各种路由选择设备)进入到网卡，然后进入到内核的 TCP/IP 协议栈(用于识别该连接请求，解封包)，还有可能要经
过防火墙(属于内核的模块)的过滤，最终达到 web 程序，最终建立了 TCP/IP 连接

建立了 TCP 连接之后，发起一个 HTTP 请求，一个典型的 HTTP Request Header 一般需要包括请求的方法，例如 GET 和 POST

- 服务器的永久重定向 HTTP 响应

服务器给浏览器响应一个 301 永久重定向响应，这样浏览器就会访问 www.baidu.com 而非 baidu.com

**为什么服务器一定要重定向而不是直接发送用户想看的内容呢？**

网站调整、网页被移到一个新地址、网页扩展名改变(如需要把 .php 改成 .html)、这种情况下，如果
不做重定向，则用户收藏夹或搜索引擎数据库的旧地址只能让访问的用户得到一条 404 消息，访问流量丧失，再者注册多域名网站，也需要重定向让用户能够访问到这些站点

**那么用 301 还是 302 好呢？**

当一个网站 24-48 小时内临时移动到一个新的位置，这时候就要 302 跳转，而使用 301 跳转的场景就是之前的站点因为某种原因永久的移除掉，然后要到新的地址访问，是永久性的

**【301 使用场景如下】**：域名到期不想续费，想换域名、空间服务器不稳定，换空间的时候、在搜索引擎的搜索结果中出现了不带 www 的域名，而带 www 的域名却没有收录，这个时候可以用 301 重定向来告诉搜索引擎我们的目标域名是哪一个

- Web 应用程序处理 HTTP 请求(以 nginx 为例)

  - nginx 读取配置文件，并寻找静态文件，如 index.php
  - 把 php 文件交给 fastcgi 进程去处理

后端从在固定的端口接收到 TCP 报文开始，它会对 TCP 连接进行处理，对 HTTP 协议进行解析，并按照报文格式进一步封装成 HTTP Request 对象，供上层使用。

- 浏览器处理并显示 html

在浏览器没有完整的接受全部 html 文档时，它就已经开始显示这个页面了，一般渲染过程

【对于 webkit 来说】解析 html 以构建 dom 树->构建 render 树->布局 render 树->绘制->render 树
