# 数据结构

## 基本概念

* [堆](#堆)
* [栈](#栈)
* [队列](#队列)
* [散列表](#散列表)
* [二叉树](#二叉树)
* [二叉查找树](#二叉查找树)
* [完全二叉树](#完全二叉树)
* [平衡二叉树](#平衡二叉树)
* [b 树、b+ 树](#b-树b-树)
* [红黑树](#红黑树)

#### 堆

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
堆也被称为优先队列，队列中允许的操作是先进先出(FIFO)，在队尾插入元素，在队头删除元素，而堆也是一样，在堆低插入元素，在堆顶删除元
素，二叉树的衍生，有着最小堆最大堆两个概念之分，将根节点大的称为大顶堆，将根节点小的称为小顶堆。常见的堆有二叉堆，斐波那契堆等。有一
个比较常见的堆排序算法正是基于此数据结构而来

#### 栈

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
栈作为一个先进后出的数据结构，它是一种运算受限的线性表，其限制是允许在表的一端进行插入和删除运算，这一端也被称为栈顶，相对地，把另
一端称为栈底。向一个栈插入新元素又称进栈，它是把新元素放在栈顶元素上面，使之成为新的栈顶元素，从一个栈删除元素又称为出栈，它是把栈
顶元素删除掉，使其相邻元素成为新的栈顶元素

#### 队列

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
队列采用先进先出(FIFO)，新元素总是被插入到链表的尾部，而读取的时候总是从链表的头部开始读取。每次读取一个新元素，就会释放一个元
素，所谓动态创建，动态释放，因而不存在溢出等问题，由于链表由结构体间接而成，遍历也方便

#### 散列表

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
哈希表也叫散列表，是根据关键码值而直接进行数据访问的数据结构，也就是说他通过把关键码值映射到表中一个位置来访问记录，以加快查找速度，这
个映射函数叫做散列函数，存放记录的数组叫做散列表，若结构中存在关键码值 x 的记录，则必定在 hash(x) 的存储位置上，由此，不需比较便可直
接取得所查记录，成这个对应关系为 hash 函数，即散列函数

-  散列地址冲突

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
哈希地址冲突，散列函数是一个压缩映像函数，关键码值比散列表地址集合大得多，因此有可能出现经过散列函数的计算，把不同的关键码值映射到同一
个散列地址上，这便是散列地址冲突

- 散列地址冲突解决办法

  - 链地址法，这种基本思想是，将所有的哈希地址为 i 的元素构成一个同义词链表，并将链表的头指针存在哈希地址为 i 的单
元中，因而查找、删除、插入主要在同义词链表中进行。

  - 开地址法(线性探测再散列)，这种基本思想是，当关键码值 key 的哈希地址 H0 = hash(key) 出现冲突时，以 H0 为基础，重新产生一个新的哈希地址 H1 依次类推，直
到不冲突为止，并将相应元素放入其中，应用这种处理哈希冲突的办法，将出现堆积现象，(散列地址不同的节点争夺同一个后继散列地址而产生的现象称为堆积)，这将
造成不是同义词的节点也将处于同一个探测序列中，从而增加了探测序列的长度，即增加了查找、删除、插入时间

#### 二叉树

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
二叉树是每个节点最多有连个节点的树结构，有五种基本状态，一般情况下二叉树的第 i 层节点数目最多为 2^(i-1)，深度为 k 的二叉树至多有 2^k - 1 个节点，包含
 n 个节点的二叉树高度至少为 log2(n+1)，在任意一棵二叉树中，度为 0 的节点数 = 度为 2 的节点数的 2 倍 + 1

- 二叉树的遍历

  - 前序遍历
```cpp
void Preorder(TreeNode* root) {
    if (root) {
        cout << root->val << endl;
        Preorder(root->left);
        Preorder(root->right);
    }
}

// 二叉树遍历前序(非递归)
void Preorder(root) {
    // 定义栈结构
    stack<TreeNode*> s;
    
    // root 非空，且栈不为空
    while (root != nullptr || !s.empty()) {
        
        // root 不空
        if (root) {

            // root 入栈
            s.push(root);

            // 打印 root->val
            cout << root->val << endl;
            root = root->left;
        } else {
            root = s.top();
            s.pop();
            if (root) {
                root = root->right;
            }
        }
    }
}
```
  - 中序遍历
```cpp
void Inorder(TreeNode* root) {
    if (root) {
        Inorder(root->left);
        cout << root->val << endl;
        Inorder(root->right);
    }
}

// 中序遍历，左根右
void Inorder(TreeNode* root) {
    stack<TreeNode> s;
    while (root) {
        s.push(root);
        root = root->left;
    }
    if (!s.empty) {
        root = s.top();
        cout << root->val << endl;
        s.pop();
        if (root) {
            root = root->right;
        }
    }
}
```
  - 后序遍历
```cpp
void Postorder(TreeNode* root) {
    if (root) {
        Postorder(root->left);
        Postorder(root->right);
        cout << root->val << endl;
    }
}
void Postorder(TreeNode* root) {
    TreeNode* cur;
    TreeNode* pre = nullptr;
    stack<TreeNode*> s;
    if (root) {
        s.push(root);
    }
    while (!s.empty()) {
        cur = s.top();
        if (cur->left == nullptr && cur->right == nullptr || pre && (cur->left == pre || cur->right == pre)) {
            cout << cur->val << endl;
            pre = cur;
            s.pop()
        } else {
            if (cur->right) {
                s.push(cur->right);
            }
            if (cur->left) {
                s.push(cur->left);
            }
        }
    }
}
```

  - 层次遍历
```cpp
void Levelorder(TreeNode* root) {
    queue<TreeNode*> q;
    if (root) {
        q.push(root);
    }
    int cur = 1;
    while (!q.empty()) {
        int count = 0;
        while (cur) {
            TreeNode* tmp = q.front();
            cout << tmp->val << endl;
            cur--;
            q.pop();
            if (tmp->left) {
                q.push(tmp_left)；
                    count++;
            }
            if (tmp->right) {
                q.push(tmp->right) {
                    count++;
                }
            }
        }
        cout << endl;
        cur = count;
    }
}
```

#### 二叉查找树

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
二叉查找树，又称为二叉搜索树，即中序遍历有序，在二叉查找树中，若任意节点的左子树不空，则左子树上所有的节点值均小于根节点的值，若右子树不空，则右子树所
有节点值均大于根节点值，二叉查找树中不存在值相同的节点

#### 完全二叉树

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
完全二叉树，在一棵二叉树中，只有最下两层节点的度可以小于 2，并且最下一层的叶节点集中在靠左的若干位置，完全二叉树与满二叉树没有必然的联系

#### 平衡二叉树

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
平衡二叉树是一种二叉查找树，其中每一个节点的左子树和右子树的高度差至多等于 1，即在二叉查找树的基础上加上了平衡因子

# 高级数据结构

#### b 树、b+ 树

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
首先 b 树属于多叉树又名平衡多路查找树

- 其规则是

  - 所有节点关键字是按递增顺序排列，并遵循左小右大规则
  - 子节点数，非叶子节点的子节点数大于 1 且小于 M，且 M > 2，空树除外
  - 关键字数，枝接点的关键字数量大于等于 ceil(m/2)-1 个且小于等于 M-1 个(注：ceil() 是个朝正无穷方向取整的函数，比如 ceil(1,1) = 2)
  - 叶节点的指针为空且叶节点具有相同的深度

- 而对于 b+ 树，是 b 树的一个升级版，相对于 b 树而言 b+ 树更充分利用了节点的空间，让查询速度更加稳定，其速度完全接近二分查找

#### 红黑树

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
RB-Tree，又称为红黑树，它是一种特殊的二叉查找树，红黑树的每个节点上都有存储位标识该节点的颜色，非红即黑

- 红黑树的特性

  - 每个节点不是红色便是黑色
  - 根节点是黑色
  - 每个叶子节点是黑色
  - 如果一个节点是红色的，则它的子节点必须是黑色的
  - 从一个节点到该节点的子孙节点的所有路径上包括相同数目的黑节点

- 红黑树的基本操作

  - 红黑树的基本操作是添加、删除，在对红黑树进行添加删除之后，都会用到旋转方法(之所以要进行旋转，是因为要在插入删除后还必须满足红黑树的性质)
  - 左旋

![左旋](https://github.com/Apriluestc/2020/blob/master/pics/%E5%B7%A6%E6%97%8B.png)

  - 右旋

![右旋](https://github.com/Apriluestc/2020/blob/master/pics/%E5%8F%B3%E6%97%8B.png)

由上述可以看出，左旋之于右旋而对称，对于 x 左旋转->将 x 变成一个左节点，右旋转->将 x 变成一个右节点

- 红黑树的插入

  - 第一步，将红黑树当作一棵二叉查找树，将节点插入
  - 第二步，将插入的节点找着色为红色
  - 通过一些列旋转和着色操作，使之重新称为一棵红黑树
  - 红黑树的插入可分为这么几种情况
  - 黑父节点(新插入节点的父节点是黑色)，不会影响其平衡性
  - 红父节点红叔节点(新插入节点的父节点是红色其叔叔节点为红色)，不会影响其平衡性，只需修改颜色即可
  - 红父节点黑叔节点(新插入节点的父节点是红色其叔叔节点为黑色)，这种情况下需要旋转
    - case:1，R 旋转
    - case:2，LR 旋转
    - case:3，RL 旋转
    - case:4，L 旋转

**红黑树如何进行插入删除？**

- 插入

  - 如果父节点为黑色，直接插入不处理
  - 如果父节点为红色，叔叔节点为红色，则父节点和叔叔节点变为黑色，祖先节点变为红色，将节点操作转换为祖先节点
  - 如果当前节点为父亲节点的右节点，则以父亲结点为中心左旋操作
  - 如果当前节点为父亲节点的左节点，则父亲节点变为黑色，祖先节点变为红色，以祖先节点为中心右旋操作

- 删除

  - 先按照排序二叉树的方法，删除当前节点，如果需要转移即转移到下一个节点
  - 当前节点，必定为这样的情况：没有左子树。
  - 删除为红色节点，不需要处理，直接按照删除二叉树节点一样
  - 如果兄弟节点为黑色，兄弟节点的两个子节点为黑色，则将兄弟节点变为红色，将着色转移到父亲节点
  - 如果兄弟节点为红色，将兄弟节点设为黑色，父亲结点设为红色节点，对父亲结点进行左旋操作
  - 如果兄弟节点为黑色，左孩子为红色，右孩子为黑色，对兄弟节点进行右旋操作
  - 如果兄弟节点为黑色，右孩子为红色，则将父亲节点的颜色赋值给兄弟节点，将父亲节点设置为黑色，将兄弟节点的右孩子设为黑色，对父亲节点进行左旋

**红黑树、b 树、b+ 树区别**

红黑树的深度比较大，而B+和B-的深度则相对要小一些，而B+较B-则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。
