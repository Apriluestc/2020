# MySQL

* [三范式](#三范式)
* [Sql 优化](#sql-优化)
* [索引及索引优化](#索引及索引优化)
* [事务](#事务)
* [存储引擎](#存储引擎)

### 三范式

- 第一范式：列的原子性，列不可分割
- 满足第一范式。除此之外，必须有主键，没有包含主键的列必须完全依赖于主键
- 满足第二范式。非主键列必须直接依赖于主键，不能传递依赖

### Sql 优化

- 只返回所需要的数据
  - 尽量不写 `select*` 的语句
  - 合理写 where 子句，不要写没有 where 的语句

  - 适当建立索引，但一下几点会进行全表扫描
  - 左模糊查询`%···`
  - 使用了不等操作符
  - Or 使用不当，or 两边必须都存在索引
  - Where 对字段进行表达式操作

- 使用 join 代替子查询

- 使用 union 代替手动创建临时表
### 索引及索引优化

- 索引
  - B+ Tree 索引
  - 哈希索引：哈希索引能以O(1)的时间复杂度进行查找，但是失去了有序性，无法用于排序与分组，只支持精确查找，无法用于部分查找和范围查找，InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找
  - 全文索引：MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射
  - 空间数据索引：MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询

### 事务

- 四大特征：原子性、一致性、隔离性、持久性
  - 一致性：指一个事务的执行前后数据库必须处于一致性状态，事务的执行结果必须是是数据库从一个一致性状态变到另一个一致性状态
  - 隔离性：一个事务的执行不能干扰其他事物，即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰

- 如果不考虑事务的隔离性，会发生的问题
  - 脏读：指在一个事务处理过程中读取了另一个未提交事务中的数据
  - 不可重复度、幻读
  - 不可重复度和幻读都是读取了另一条已提交的事务，不可重复度重点在于 update 和 delete，而幻读重点在于 insert
  - 在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复 读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力

- 四种隔离级别
  - 串行化 ：可避免脏读、不可重复度、幻读的放生
  - 可重复度（默认）：可避免脏读、不可重复度的发生
  - 读已提交：可避免脏读的发生
  - 读未提交：最低极别，任何情况都无法保证

- 锁模式
  - 共享锁：（读取）操作创建的锁，其他用户可以并发读取数据，任何事物都不能获取数据上的排他锁，直到已经释放共享锁
  - 排他锁（X 锁）：对数据 A 加上排他锁以后，则其他事物不能再对 A 添加任何锁，或者排他锁的事务既能读数据又能修改数据
  -更新锁（U 锁）：更新锁可以防止通常形式的死锁，如果两个事物获得了资源上的共享锁，然后试图更新数据，则两个事物都需要转换共享锁为排他锁，并且每个事物都等待另一个事务释放共享锁，因此阻塞发生死锁
  - 若要避免上述问题，请使用更新锁（U 锁），一次只有一个事务可以获得资源的更新锁，如果事务修改资源，则更新锁转换为排他锁，否则转换为共享锁

- 锁粒度
  - 行锁、页锁、表锁、数据库锁

### 存储引擎

**MyISAM 和 Innodb 的区别**

- InnoDB 支持事务，MyISAM 不支持，对于 InnoDB 每一条 SQL 语句都默认封装成事务提交，这样就会影响
速度，优化速度的方式是将多条 SQL 语句放在 begin 和 commit 之间，组成一个事务
- InnoDB 支持外键，而 MyISAm 不支持
- InnoDB 不支持全文索引，而 MyISAM 支持，查询效率上 MyISAM 要高

如果一个表修改要求比较高的事务处理，可以选择 InnoDB，这个数据库中可以将查询要求比较高的表选择 MyISAM 存储，如果
该数据库需要一个用于查询的临时表，甚至可以考虑选择 MEMORY 存储引擎

**存储引擎原理**

- MyISAM 中 B+ 树的数据结构存储内容是实际的地址值，它的索引和实际数据是分开的，只不过使用索引指向了实际数据，这种索引的模式成为非聚簇索引

- InnoDB 中 B+ 树的数据结构中存储的都是实际的数据，这种索引又被称为聚簇索引

**什么是索引呢**

- 唯一索引：唯一索引不允许两行具有相同的索引值
- 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型，主键索引要求主键
中的每个值都是唯一的
- 聚簇索引：表中各行的物理顺序与键值的逻辑顺序相同，每个表只能有一个
- 非聚簇索引：非聚簇索引指定表的逻辑顺序，数据存储在一个位置，索引存储在另外一个位置，索引中
包含指向数据存储位置的指针，小于 249

**MyISAM**

回到 MyISAM，其索引结构如下图所示，由于 MyISAM 的索引文件仅仅保存数据记录的地址。在 MyISAM 中，主索引和辅助索引（Secondary key
）在结构上没有任何区别：

MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。

【MyISAM】![](https://github.com/Apriluestc/2020/blob/master/pics/myisam.png)

**InnoDB**

对于 InnoDB 来说，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。

由于 InnoDB 利用的数据库主键作为索引 Key，所以 InnoDB 数据表文件本身就是主索引，且因为 InnoDB 数据文件需要
按照主键聚集，所以使用 InnoDB 作为数据引擎的表需要有个主键，如果没有显式指定的话 MySQL 会尝试自动选择一个可以
唯一标识数据的列作为主键，如果无法找到，则会生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

【InnoDB】![](https://github.com/Apriluestc/2020/blob/master/pics/innodb.png)

#### b 树和 b+ 树

【原理】https://github.com/Apriluestc/2020/blob/master/doc/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md#b-%E6%A0%91b-%E6%A0%91
