# 算法

* [排序算法](#排序算法)
* [查找算法](#查找算法)
* [背包问题](#背包问题)
* [无锁队列](#无锁队列)

#### 排序算法

- 堆排序【nlogn、nlogn、1、不稳定】

简单来说，堆排序是一种基于二叉堆结构的排序算法，所谓二叉堆，我们通过完全二叉树来对比
，只不过相比较完全二叉树而言，二叉堆的所有父节点值都大于或小于它的孩子节点

堆排序方法，把大顶堆堆顶的最大数取出，将剩余的堆继续使用向下调整为大顶堆，再次取出堆顶元素，这个过程持
续到堆里面只有一个元素为止

- 快速排序【nlogn、n^2、logn、不稳定】

在区间中随机挑选一个元素作为基准，将小于基准的元素放到基准之前，大于基准的元素放到基准之后，
**选择一个数作为基准，将比基准小的元素交换到前面，比基准大的元素交换到基准后面，对左右区间重复，直到各区间只有一个数**

快排流程：以 6 为基准

初始数组：6 1 2 7 9 3 4 5 10 8

第一次比较：6 1 2 5 9 3 4 7 10 8

第二次：6 1 2 5 4 3 9 7 10 8

第三次：1 2 3 4 3 6 9 7 10 8

| 初始数组 |  6   |  1   |  2   |  7   |  9   |  3   |  4   |  5   |  10  |  8   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  第一次  |  6   |  1   |  2   |  5   |  9   |  3   |  4   |  7   |  10  |  8   |
|  第二次  |  6   |  1   |  2   |  5   |  4   |  3   |  9   |  7   |  10  |  8   |
|  第三次  |  1   |  2   |  5   |  4   |  3   |  6   |  9   |  7   |  10  |  8   |

一种简单的快排实现

```cpp
void quicksort(vector<int> v, int low, int high) {
    if (low >= high) {
        return ;
    }
    // 高低位下标
    int left = low, right = high;
    // 基准
    int base = v[left];
    while (left < right) {
        while (left < last && v[right] >= base) {
            right--;
        }
        // 将比基准小的移到前面
        if (left < right) {
            v[left++] = v[right];
        }
        while (left < right && v[left] <= base) {
            left++;
        }
        // 将比基准大的移到后面
        if (left < right) {
            v[right--] = v[left];
        }
        v[left] = base;
        quick(v, low, left - 1);
        quick(v, left + 1, high);
    }
}
```

**【快排的优化】**，固定基准随机化、三数取中、当排序长度达到一定长度后用插入排序、分割一次后将相同数据不做处理、使用并行或者多线程、使用尾递归优化【即将 logn 降解为更低的时间复杂度】

**【基准随机化算法】**，使用随机数生成函数在一定区间生成一个随机数，范围为 [left, right]，并用此随机数为下标对应的元素 v[rand] 作为基准，并与最后一个元素 v[right] 交换，然后进行与选取最后一个元素
最为基准，继续快排

优点；基准随机化，将恶劣情况几率减小，随机化快排能达到 nlogn 的时间复杂度

```cpp
int random(int left, int right) {
    return rand() % (right - left + 1) + left;
}
```

**【三数取中】**，虽然随机化基准的引入能达到 nlogn，但是最坏情况还是 n^2，为了缓解最坏时间，引入三数取中

思路，假设数组被排序的范围为 left 和 right，center =(left+right) / 2，对 a[left]、a[right] 和 a[center] 进
行适当排序，取中值为中轴，将最小者放 a[left]，最大者放在 a[right]，把中轴元与 a[right-1]交换，并
在分割阶段将 i 和 j 初始化为 left+1 和 right-2。然后使用双向描述法，进行快排

例子：注意观察 0 4 6

初始数组：6 1 8 9 4 3 5 2 7 0

选取三个中间数：6 1 8 9 4 3 5 2 7 0

对这三个数排序：0 1 8 9 4 3 5 2 7 6

最后中轴与 v[right-1] 交：0 1 8 9 7 3 5 2 4 6

优点：

1.将三元素中最小者被分到 a[left]、最大者分到 a[right]是正确的，因为当快排一趟后，比中轴小的放到左边，而比中轴大的放到右边，这样就在分割的时候把它们分到了
正确的位置，减少了一次比较和交换。

2.在前面所说的所有算法中，都有双向扫描时的越界问题，而使用这个分割策略则可以解决这个问题。因为 i 向右扫描时，必然会遇到不小于中轴的数 a[right-1]，而 j 在向左扫描时，必然会遇
到不大于中轴的数 a[left]，这样，a[right-1] 和 a[left] 提供了一个警戒标记，所以不需要检查下标越界的问题。

分析：最佳的划分是将待排序的序列分成等长的子序列，最佳的状态我们可以使用序列的中间的值，也就是第 N/2 个数。可是，这很难算出来，并
且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为枢纽元而得到。事实上，随机性并没有多大的帮助，因此
一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元。显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约14%的
比较次数

**【待排序列达到一定长度后用插排，一般长度为 10】**，在数组中如果有相等元素，那么可以减少不必要的划分

**【尾递归优化】**，优点：如果待排序的序列划分极端不平衡，递归的深度将趋近于 n，而栈的大小是很有限
的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的 O(n) 缩减为 O(logn)，将会
提高性能

【尾递归减少递归深度】

- 冒泡排序【n^2、n^2、1、稳定】

冒泡排序思路，遍历序列，相邻两元素比较且交换

```cpp
void bubblesort(vector<int> v, int size) {
    bool flags = false;
    // 剩余一个元素无需比较且交换
    for (int i = 0; i < size - 1 && !flags; ++i) {
        flags = true;
        for (int j = 0; j < size - 1 - i; ++j) {
            if (v[j] > v[j+1]) {
                swap(v[j], v[j+1]);
            }
        }
    }
}
```

- 插入排序【n^2、n^2、1、稳定】

插入排序思路，**八无序区的第一个元素插入到有序区的合适位置，从第一个元素开始，该元素可以认为已经有序，取出下一个元素，在已排序的元素序列中向后扫描，如
果该元素大于新元素，将该元素移到下一个位置，重复上述，直到找到已排序的元素小于等于新元素的位置，将新元素插入到该位置后，继续上述步骤**

```cpp
void insertsort(vector<int> v, int size) {

    // 无序区的第一个元素
    for (int i = 1; i < size; ++i) {
        int temp = v[i];
    }

    // 插入到合适位置
    for (int j = i - 1; j >= 0; --j) {
        if (v[j+1] > temp) {
            v[j+1] = v[j];
            v[j] = temp;
        } else
            break;
    }
}
```

- 桶排序【n、n、m、稳定】

桶排序思路，将值为 i 的元素放入 i 号桶，最后依次将元素倒出来，**设置一个定量数目的数组当作空桶，遍历序列，并且把元素一个一个放入对应的桶中，
对每个不是空的桶子进行排序，从不是空的桶子里把元素放回原来的序列中**

- 归并排序【nlogn、nlogn、n、稳定】

#### 查找算法

- 二分查找【logn、1、有序】

- 顺序查找【n、1、无序或有序】

- 二叉查找树查找【logn】

- 哈希查找【1，m、无序或有序】

#### 背包问题

- 01 背包

- 多重背包

#### 无锁队列

- CAS 实现无锁队列
