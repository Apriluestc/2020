# Web

### 介绍以下这个项目

本项目为 C++ 11 编写的高性能 Web 服务器，使用状态机解析了 GET、POST 请求，可静态处理资源，支
持 HTTP 长连接、支持管线化请求，并实现了异步日志，实时记录服务器运行状态，
经 webbench 测试该服务器可达 30000 并发量

### 定时器怎么实现的？还有什么实现方式？

**【定时器实现】**

|    定时器    | StartTimer | StopTimer | PerTickBookkeeping |
| :----------: | :--------: | :-------: | :----------------: |
|  基于小根堆  |    logn    |     1     |         1          |
| 基于排序链表 |     n      |     1     |         1          |
|  基于时间轮  |     1      |     1     |         1          |

### 实现一个无锁队列

【详见】https://github.com/Apriluestc/2020/blob/master/doc/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95.md#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97

### eventfd 是什么？有什么好处

在 Reactor 模式中，为了能流畅处理多个客户端的连接，通常情况下会有一个主进程和多个工作进程，
主进程负责 accept 新连接并生成新连接的 socketfd，然后再将这些 fd 分发给数个工作进程，其中主线程
向子线程(work_thread)分发 fd 的方式在 Linux 平台上常见的有三种，分别是 pipe、eventfd、socketpair，
跨线程异步唤醒，将生成的 eventfd 绑定到 epoll_fd 上，需要时向这个 eventfd 上写入一个字节，工作线程立即被唤醒，
**eventfd 是 Linux 引入的一种轻量级的 IPC 方式，不同进程可以通过 eventfd 建立起一个共享的计数器，这个计数器由内核维护，
充当信息的角色，与他关联的进程可以进行读写，从整体上来讲，eventfd 更加有优势，仅仅通过一个文件描述符，便实现了读写功能，
而 pipe 和 socketpair 都占用两个 fd**

```cpp
int eventfd(unsigned int initval, int flags);
```

### 异步日志是什么？为什么要这么做？

首先多线程异步日志需要线程安全的保证，即多个线程可以写日志文件而不发生错乱，简单的线程安全并不难办到，用一个
全局的 Mutex 对日志的 IO 操作进行保护或者单独写一个日志文件即可，但是前者会造成多个线程竞争锁资源，后者会造成某个业务线程阻塞

本项目可行的解决方案就是，用一个背景线程负责收集日志消息并将其写入后端，其他业务线程只负责生成的日志消息并将其传输到日志线程，这便是异步日志

日志的实现应用双缓冲区技术，即存在两个 Buffer，日志的实现分为前端和后端， 前端负责向 CurrentBuffer 中写，后端负责
将其写入文件中，具体来说，当 CurrentBuffer 写满时，先将 CurrentBuffer 中的消息存入 Buffer 中，在交换 CurrentBuffer 和 NextBuffer，这样
前端就可以继续往 CurrentBuffer 中写新的日志消息， 最后再调用 notify_all 通知后端将其写入文件

### 什么是优雅关闭连接？

所谓优雅关闭连接就是(就是 read() 到 0，要透明的传递这个行为而不是直接暴力 close())，一般情况下我们使用 close() 来关闭套接字，
所谓关闭套接字就是，将套接字描述符(或句柄)从内存中清除，之后再也不能使用该套接字，直接调用 close() 会立即向网络中发送 FIN 包，
不管输出缓冲区是否有数据，所以调用 close() 将丢失缓冲区数据

而调用 shutdown() 则会等待输出缓冲区中的数据传输完毕再发送 FIN 包，也就是我们所说的(read 到 0)，这便是优雅关闭连接，而不是暴力 close

### Epoll 的边沿触发和水平触发有什么区别？

epoll 有 EPOLLLT 和 EPOLLET 两种触发模式，LT 是默认的模式，ET 是“高速”模式。LT 模式下，只要这个 fd 还有数据可读，每次 epoll_wait 都会返回它的事件，提
醒用户程序去操作，而在 ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论 fd 中是
否还有数据可读。所以在 ET 模式下，read 一个 fd 的时候一定要把它的 buffer 读光，也就是说一直读到 read 的返回值小于请求值，或者 遇到 EAGAIN 错误

### Epoll 为什么高效，相较于 select、poll？
### HTTP 报文有哪些字段？

**通用首部字段**

- Cache-Control：控制缓存行为
- Connection：控制不在转发给代理的首部字段、管理持久连接
- Date：创建报文时间
- Warning：错误通知

**请求首部字段**

- Accept：用户代理可处理的媒体类型
- Authorization：期待 Web 服务器的特定行为
- User-Agent：HTTP 客户端程序信息

**响应首部字段**

- Accept-Ranges：是否接受字节范围请求
- ETag：资源匹配信息
- Location：零客户端重定向至特定 URL

**实体首部字段**

- Allow：资源可支持的 HTTP 方法
- Content-Length：实体主体的大小
- Content-Location：替代对应资源的 URI
- Last-Modified：资源的最后修改时间

### 加入服务器要升级，又不想让用户感知这个行为，怎么做？

在我们版本运行之初，可以这么理解，已经将完好的版本发布，现在要对其进行升级，但是又不要用
户感知自己的服务器的升级行为，我们可参考 nginx 平滑升级

- nginx 平滑升级

当前服务器正在运行 nginx 服务，现对 nginx 进行升级(且跨度不大，容易造成服务崩溃)且在不停止
服务的情况下进行升级

**具体过程**

- 在不停掉旧进程的情况下，启动新进程
- 就进程负责处理仍然没有处理完的请求，但不接收新请求
- 新进程负责接受请求
- 老进程处理完所有请求，关闭所有连接后，服务终止

### 一个请求到来具体的处理过程是什么样的？
### 线程的唤醒方式还有哪些？
### 怎么检查内存泄漏？

Windows 下，前提 Debug 环境下可以通过 VLD 和 CRT 这两个库本身的内存泄漏函数定位内存泄漏，相对而言简单一些

Release 环境下：

- 对象计数

在对象构造时计数 ++，析构时 --，每隔一段时间打印对象的数量

**优点**：没有性能开销，几乎不占内存，定位结果准确

**缺点**：侵入式方法，需修改现有代码，而且对于第三方库、STL 容器、脚本泄漏等无法修改代码而定位内存泄漏

- 重载 New / delete

**优点**：没啥优点

**缺点**：侵入式方法，需要修改现有代码，需要将头文件加入到大量源文件的头部，以确保重载的宏能够覆盖所有的 New 和 delete，记录分配点需要
加锁(对于多线程)，记录分配电需要大量内存

Linux 下使用 valgrind 可以很方便的定位内存泄漏

最常用的格式：`valgrind --tool = memcheck --leak-check=full ./target`


### 用到了哪些智能指针和 RAII 机制，几种锁的区别是什么？

shared_ptr

weak_ptr

### 任务队列怎么实现的？除了加锁还有什么实现方式？

条件变量搭配互斥锁、CAS

### 如何解决死锁？

- 死锁预防(有序资源分配)、(银行家算法)

死锁产生的四个必要条件：互斥、不可抢占、占有且申请、循环等待

这是一种事先预防的办法，通过设置某些限制条件，去破坏产生死锁四个必要条件中的一个或多个，来预防死锁，**缺点，
施加限制条件太过严格，导致系统资源利用率和吞吐量降低**

- 死锁避免

系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否
分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死
锁状态的动态策略

- 死锁检测和解除

### 怎么进行压测的？

`webbench -t 60 -c 1000 -2 -k 39.107.70.253:20000/`

### 为什么要用非阻塞 IO？
### Reactor 模式是什么？

Reactor 模式可以简单概括为，服务器端为了能流畅处理多个客户端连接，一般在某个进程 A 里面 accept 新的
客户端连接并生成新连接的 socketfd，然后将这些新连接的 socketfd 分发数个工作线程 B1、B2、B3、···，这
些工作线程监听并处理这些新连接上的网络 IO 事件(即收发数据)，同时，还处理系统中的一些事务，这里我们将 A 称为
主线程，B1、B2、B3、···，等称为工作线程，工作线程的代码框架一般如下：

```cpp
while (!m_quit) {
    
    // 负责通过 epoll()/poll()/select() 去检测 socketfd 上的 IO 事件，
    // 若存在这些事件，则下一步 handle_io_events() 来处理这些事件(收发数据)，做完之后可
    // 能还要做一些系统其他任务，即调用 handle_others_things()
    epoll_or_select_func();
    handle_io_events();
    handle_other_things();
}
```

### TCP 收发环形缓冲区怎么实现的？
### 什么是 dameon 进程？dameon 进程创建原理是什么？

Linux daemon 是运行于后台常驻内存的一种特殊进程，周期性的执行或者等待 trigger 执行某个任务，与用户交互断开，独
立于控制终端。 一个守护进程的父进程是 init 进程，它是一个孤儿进程，没有控制终端，所以任何输出，无论是向标
准输出设备 stdout 还是标准出错设备 stderr 的 输出都被丢到了 /dev/null 中。守护进程一般用作服务
器进程，如 httpd，syslogd 等。

**进程、进程组、会话、控制终端之间的关系**

- 进程组：由一个或者多个进程组成，进程组号(GID)，就是这些进程中的进程组长的 PID

- 会话：又叫会话期，它包括了期间所有的进程组，一般一个会话开始于用户 login，一般 login 的是 shell 的终端，所以 shell 是此次 会话的shoul 首进程，会话一般结束于 logout，对于非进程组长，它可以调用 setid() 创建一个新的会话

- 控制终端：一般指 shell 的终端，它在会话期可有可没有

**创建守护进程**

- 首先让其成为后台进程

用 fork 创建进程，父进程退出，子进程称为孤儿进程被 init 进程接管，子进程变为后台进程

- 脱离父进程控制终端，登录会话和进程组

调用 setid() 让子进程称为成为新会话的组长，脱离父进程的会话期，setid() 在调用者是某进程组的组长时
会失败，但是前提保证调用者不是组长即可 之后子进程变为新会话期的组长

- 控制进程重新开启控制终端

因为会话组的组长有权限重新打开控制终端，所以这里第二次 fork 将子进程结束，留着孙进程，孙进程不是会话组的组长所以没有权利再
打开控制终端，这样整个程序就与控制终端隔离了

- 关闭文件描述符

进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误

- 重定向 0，1，2 标准文件描述符

将三个标准文件描述符定向到 /dev/null 中

- 改变工作目录和文件掩码

进程活动时，其工作目录所在的文件系统不能卸下(比如工作目录在一个 NFS 中,运行一个 daemon 会导致 umount 无法成功)。一
般需要将工作目录改变 到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如 chdir("/tmp")，进程从
创建它的父进程那里继承 了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：umask(0);

### nginx 的并发模型是什么？或者说它是如何处理高并发的？
### 你做这个项目的初衷是什么？为什么要做这个项目？

前情提要，之前看过 TinyHttpd 源码，想自己写一个 Web 服务器，由于当时能力有限， 就从去年推到今年的 1 月份，在脑海里有这个项
目之前，我们老师曾经推荐好几本书， 我下去看了看，诸如：《C++ 编程思想》、《C 和指针》、《C++ Primer》、《侯捷 STL 源码剖
析》、《TCP/IP 详解 卷 1》、《高性能服务器编程》、《现代操作系统》、《计算机网络》等，这些书本涵盖了：

- 多线程编程、Socket 编程、泛型编程
- TCP/IP 协议、通信协议
- IO 相关
- 多线程相关同步原语
- dameon 进程创建原理
- 版本控制 git、Makefile、shell、编程规范

做完这个项目刚好可以把握所学的知识在秋招前复习一遍，哈哈哈哈哈哈哈，迫不及待

后续项目中进行重构，采用智能指针代替全裸的指针，借鉴 muduo 思想、林亚 写的项目以及陈帅豪项目，把我的 web.d 重构了一番
