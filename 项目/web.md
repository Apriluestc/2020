# Web

* [介绍以下这个项目](#介绍以下这个项目)
* [定时器怎么实现的？还有什么实现方式？](#定时器怎么实现的-还有什么实现方式-)
* [实现一个无锁队列](#实现一个无锁队列)
* [eventfd 是什么？有什么好处](#eventfd-是什么-有什么好处)
* [异步日志是什么？为什么要这么做？](#异步日志是什么-为什么要这么做-)
* [什么是优雅关闭连接？](#什么是优雅关闭连接-)
* [Epoll 的边沿触发和水平触发有什么区别？](#epoll-的边沿触发和水平触发有什么区别-)
* [Epoll 为什么高效，相较于 select、poll？](#epoll-为什么高效-相较于-select-poll-)
* [HTTP 报文有哪些字段？](#http-报文有哪些字段-)
* [加入服务器要升级，又不想让用户感知这个行为，怎么做？](#加入服务器要升级-又不想让用户感知这个行为-怎么做-)
* [一个请求的到来具体的处理过程是什么样的？](#一个请求的到来具体的处理过程是什么样的-)
* [线程池的作用是什么？](#线程池的作用是什么-)
* [线程的唤醒方式还有哪些？](#线程的唤醒方式还有哪些-)
* [怎么检查内存泄漏？](#怎么检查内存泄漏-)
* [用到了哪些智能指针和 RAII 机制，几种锁的区别是什么？什么是 RAII 资源管理？](#用到了哪些智能指针和-raii-机制-几种锁的区别是什么-什么是-raii-资源管理-)
* [任务队列怎么实现的？除了加锁还有什么实现方式？](#任务队列怎么实现的-除了加锁还有什么实现方式-)
* [死锁的原因？条件？如何预防？如何避免？如何解除？](#死锁的原因-条件-如何预防-如何避免-如何解除-)
* [怎么进行压测的？](#怎么进行压测的-)
* [为什么要用非阻塞 IO？](#为什么要用非阻塞-IO-)
* [Reactor 模式是什么？](reactor-模式是什么-)
* [TCP 收发环形缓冲区怎么实现的？](#tcp-收发环形缓冲区怎么实现的-)
* [什么是 dameon 进程？dameon 进程创建原理是什么？](#什么是-dameon-进程-dameon-进程创建原理是什么-)
* [nginx 的并发模型是什么？或者说它是如何处理高并发的？](#nginx-的并发模型是什么-或者说它是如何处理高并发的-)
* [你做这个项目的初衷是什么？为什么要做这个项目？](#你做这个项目的初衷是什么-为什么要做这个项目-)

### 介绍以下这个项目

本项目为 C++ 11 编写的高性能 Web 服务器，使用状态机解析了 GET、POST 请求，可静态处理资源，支
持 HTTP 长连接、支持管线化请求，并实现了异步日志，实时记录服务器运行状态，
经 webbench 测试该服务器可达 30000 并发量

### 定时器怎么实现的？还有什么实现方式？

**【定时器实现】**

|    定时器    | StartTimer | StopTimer | PerTickBookkeeping |
| :----------: | :--------: | :-------: | :----------------: |
|  基于小根堆  |    logn    |     1     |         1          |
| 基于排序链表 |     n      |     1     |         1          |
|  基于时间轮  |     1      |     1     |         1          |

### 实现一个无锁队列

【详见】https://github.com/Apriluestc/2020/blob/master/doc/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95.md#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97

### eventfd 是什么？有什么好处

在 Reactor 模式中，为了能流畅处理多个客户端的连接，通常情况下会有一个主进程和多个工作进程，
主进程负责 accept 新连接并生成新连接的 socketfd，然后再将这些 fd 分发给数个工作进程，其中主线程
向子线程(work_thread)分发 fd 的方式在 Linux 平台上常见的有三种，分别是 pipe、eventfd、socketpair，
跨线程异步唤醒，将生成的 eventfd 绑定到 epoll_fd 上，需要时向这个 eventfd 上写入一个字节，工作线程立即被唤醒，
**eventfd 是 Linux 引入的一种轻量级的 IPC 方式，不同进程可以通过 eventfd 建立起一个共享的计数器，这个计数器由内核维护，
充当信息的角色，与他关联的进程可以进行读写，从整体上来讲，eventfd 更加有优势，仅仅通过一个文件描述符，便实现了读写功能，
而 pipe 和 socketpair 都占用两个 fd**

```cpp
int eventfd(unsigned int initval, int flags);
```

### 异步日志是什么？为什么要这么做？

首先多线程异步日志需要线程安全的保证，即多个线程可以写日志文件而不发生错乱，简单的线程安全并不难办到，用一个
全局的 Mutex 对日志的 IO 操作进行保护或者单独写一个日志文件即可，但是前者会造成多个线程竞争锁资源，后者会造成某个业务线程阻塞

本项目可行的解决方案就是，用一个背景线程负责收集日志消息并将其写入后端，其他业务线程只负责生成的日志消息并将其传输到日志线程，这便是异步日志

日志的实现应用双缓冲区技术，即存在两个 Buffer，日志的实现分为前端和后端， 前端负责向 CurrentBuffer 中写，后端负责
将其写入文件中，具体来说，当 CurrentBuffer 写满时，先将 CurrentBuffer 中的消息存入 Buffer 中，在交换 CurrentBuffer 和 NextBuffer，这样
前端就可以继续往 CurrentBuffer 中写新的日志消息， 最后再调用 notify_all 通知后端将其写入文件

**标准 IO 和文件 IO 的区别**

文件 IO：文件 IO 也被称为不带缓存的 IO，不带缓存指的是每个 read、write 都调用内核中的一个系统调用，也就是低级 IO --操作系统提供的 IO 操作，与 OS 绑定。特定与 Linux 和 Unix 平台

标准 IO：标准 IO 是一个便准函数包和 stdio.h 头文件的定义，具有一定的可以移植性，有缓存，标准 IO 提供了三种类型的缓存

- 全缓存：当填满标准 IO 缓冲区才进行实际的 IO 操作
- 行缓存：当输入或输出中遇到换行符时，标准 IO 执行 IO 操作
- 不带缓存：stderr 便是

**区别**

文件 IO 又称为低级磁盘 IO，其进行读写文件时，每次操作都会与系统调用绑定，这样处理的好处是直接读写文件，坏处是系统调用会直接增加系统开销，标准 IO 可以看成是
在文件 IO 的基础上封装了缓冲机制，先读写缓冲区，必要时再访问实际文件，从而减少系统调用的次数，文件 IO 中用文件描述符表现为一个打开的文件，可以访问不同类型的文件，如普通文件、设备文件等，
而标准 IO 中用 FILE 流标识一个打开的文件，通常只访问普通文件

标准 IO 函数：fopen、fclose、fread、fwrite、fputs等

文件 IO 函数：open、close、read、write

### 什么是优雅关闭连接？

所谓优雅关闭连接就是(就是 read() 到 0，要透明的传递这个行为而不是直接暴力 close())，一般情况下我们使用 close() 来关闭套接字，
所谓关闭套接字就是，将套接字描述符(或句柄)从内存中清除，之后再也不能使用该套接字，直接调用 close() 会立即向网络中发送 FIN 包，
不管输出缓冲区是否有数据，所以调用 close() 将丢失缓冲区数据

而调用 shutdown() 则会等待输出缓冲区中的数据传输完毕再发送 FIN 包，也就是我们所说的(read 到 0)，这便是优雅关闭连接，而不是暴力 close

### Epoll 的边沿触发和水平触发有什么区别？

epoll 有 EPOLLLT 和 EPOLLET 两种触发模式，LT 是默认的模式，ET 是“高速”模式。LT 模式下，只要这个 fd 还有数据可读，每次 epoll_wait 都会返回它的事件，提
醒用户程序去操作，而在 ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论 fd 中是
否还有数据可读。所以在 ET 模式下，read 一个 fd 的时候一定要把它的 buffer 读光，也就是说一直读到 read 的返回值小于请求值，或者 遇到 EAGAIN 错误

### Epoll 为什么高效，相较于 select、poll？

#### select

- select 模型：因为一个进程打开的 fd 是有限制的，由 FD_SETSIZE 设置，默认是 1024，因此 select 模型的最大并发数就被相应的限制了

- 效率问题：select 每次调用都会线性扫描全部 fd 集合，效率呈线性下降，如果将 FD_SETSIZE 改大，可能会造成 fd 超时

- 内核/用户空间拷贝问题：select 采用了内存拷贝，无论 poll、select、epoll 都要把 fd 消息通知给用户空间，而 select 和 poll 都采用内存拷贝，显然效率低下

#### poll

- poll解决了 select 最大并发限制，但是 select 的效率问题和拷贝问题却依然存在

#### epoll

- 拷贝问题：epoll 通过内核与用户空间的 mmap 同一块内存实现，这样就避免了大量的 fd 跨空间拷贝，即避免了不必要的拷贝

- epoll 支持打开大数目 fd，具体数目 `cat /proc/sys/fs/file-max`

- epoll-API：
  
  - epoll_create，创建 epoll 句柄
  - epoll_ctl，事件注册函数
  - epoll_wait，收集 epoll 监控的事件中已发送的事件

**epoll 为什么高效**

- 从 API 调用方式来看，select/poll 每次都要传递索要监控的 fd 集合给 select/poll 系统调用(这意味着将所有的 fd 跨空间拷贝，耗时)，而每次调用 epoll_wait 时(相当于调用 select/poll)，
不需要传递 fd 给内核，只需要进行增量式操作，所以在 epoll_create 之后，内核已经在内核态开始准备数据结构存放监控的 fd 了，每次调用 epoll_ctl 时只是对这个数据结构进行简单的维护

- 此外，内核使用了 slab 机制，为 epoll 提供了快速的数据结构，在内核里一切皆文件，所以 epoll 向内核注册了一个文件系统，用于存储被监控的 fd，当调用 epoll_create 时，就会在这个虚拟的 epoll 文件系统里，
创建一个 file 节点，当然这个 file 不是普通文件，它只服务于 epoll，epoll在被内核初始化时(操作系统启动)，同时会开辟出 epoll 自己的内核高速 cache 区，用于安置每一个我们想监控的 fd，这
些 fd 会以红黑树的形式保存在内核 cache 里，以支持快速的查找、插入、删除，在这个内核高速 cache 区，就是建立连续的物理内存页，然后在之上建立 slab 层，简单地说，就是物理上分配好你想要的 size 的内存对象，
每次使用时都是使用空闲的已分配好的对象

- 当我们调用 epoll_ctl 往里塞入百万 fd 时，epoll_wait 仍能飞快的返回，并有效的将发生事件的 fd 给我们用户，这是由于我们在调用 epoll_create 时，内核除了帮我们在 epoll 文件系统里创建 file 节点，在内核 cache 区建
了个红黑树用于存储 epoll_ctl 传来的 fd，还会建立一个 list 链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观测 list 有无数据即可，有数据返回，无数据 sleep，等到 timeout 事件页返回，通常情况下我们要监控百万计的 fd，
大多一次也只返回少量的 fd，所以 epoll_wait 仅需要从内核态拷贝少量 fd 到用户态，那么如何维护这个就绪的 list 链表，当我们执行 epoll_ctl 时，除了把 fd 放到 epoll 文件系统 file 对象对应的红黑树之外，还会给内核中断处理程序注册一个 CallBack，
告诉内核，如果这个 fd 到了，就把他放到就绪 list 中

#### 总结

**如此，一颗红黑树，一张准备就绪的 list 链表，少量的内核 cache，就帮我们解决了高并发下的 fd 处理问题**

**执行 epoll_create 时创建红黑树和就绪 list 链表**

**执行 epoll_ctl 时，如果增加 fd，则检查在红黑树中是否存在，存在立即返回，否则添加，然后向内核注册回调函数，用于当中断事件来临时向 list 中插入数据**

**执行 epoll_wait 时立即返回就绪 list 中的数据**

![Add img](https://github.com/Apriluestc/2020/tree/master/pics/epoll.png)

### HTTP 报文有哪些字段？

**通用首部字段**

- Cache-Control：控制缓存行为
- Connection：控制不在转发给代理的首部字段、管理持久连接
- Date：创建报文时间
- Warning：错误通知

**请求首部字段**

- Accept：用户代理可处理的媒体类型
- Authorization：期待 Web 服务器的特定行为
- User-Agent：HTTP 客户端程序信息

**响应首部字段**

- Accept-Ranges：是否接受字节范围请求
- ETag：资源匹配信息
- Location：零客户端重定向至特定 URL

**实体首部字段**

- Allow：资源可支持的 HTTP 方法
- Content-Length：实体主体的大小
- Content-Location：替代对应资源的 URI
- Last-Modified：资源的最后修改时间

### 加入服务器要升级，又不想让用户感知这个行为，怎么做？

在我们版本运行之初，可以这么理解，已经将完好的版本发布，现在要对其进行升级，但是又不要用
户感知自己的服务器的升级行为，我们可参考 nginx 平滑升级

- nginx 平滑升级

当前服务器正在运行 nginx 服务，现对 nginx 进行升级(且跨度不大，容易造成服务崩溃)且在不停止
服务的情况下进行升级

**具体过程**

- 在不停掉旧进程的情况下，启动新进程
- 就进程负责处理仍然没有处理完的请求，但不接收新请求
- 新进程负责接受请求
- 老进程处理完所有请求，关闭所有连接后，服务终止

### 一个请求的到来具体的处理过程是什么样的？

新连接到来，主线程负责 Accept 新的连接并生成新连接的 socketfd，然后将这个新连接的 fd 以轮询(Round Robin)的方式发送给工作线程，这里涉及到跨线程任务分配，需要加锁，这里的锁
由某个特定任务的线程中的 loop 创建，制会被该线程和主线程竞争，本项目中主线程向子线程
分发 fd 采用了 eventfd 方式，来唤醒工作线程，这些工作线程再负责处理这些新连接上的网络 IO 事件(收发数据)，每个工作线程持有一个 Timer 用于处理超时请求，
工作线程都做了(read、write、Decode、Encode 等)，

### 线程池的作用是什么？

处理线程高并发，用一个数组保存线程，然后一直放着，如果没用就用条件变量让它休眠，如果加入一个新的任务就唤醒其中一个去执行这个任务

**pthread_cond_signal 和 pthread_cond_broadcast 的区别？**

Pthread_cond_signal表示唤醒睡眠线程中的一个【单播，可能按照优先级或者先来后到的原则】

Pthread_cond_boardcast表示唤醒所有睡眠线程【广播】

### 线程的唤醒方式还有哪些？
### 怎么检查内存泄漏？

Windows 下，前提 Debug 环境下可以通过 VLD 和 CRT 这两个库本身的内存泄漏函数定位内存泄漏，相对而言简单一些

Release 环境下：

- 对象计数

在对象构造时计数 ++，析构时 --，每隔一段时间打印对象的数量

**优点**：没有性能开销，几乎不占内存，定位结果准确

**缺点**：侵入式方法，需修改现有代码，而且对于第三方库、STL 容器、脚本泄漏等无法修改代码而定位内存泄漏

- 重载 New / delete

**优点**：没啥优点

**缺点**：侵入式方法，需要修改现有代码，需要将头文件加入到大量源文件的头部，以确保重载的宏能够覆盖所有的 New 和 delete，记录分配点需要
加锁(对于多线程)，记录分配电需要大量内存

Linux 下使用 valgrind 可以很方便的定位内存泄漏

最常用的格式：`valgrind --tool = memcheck --leak-check=full ./target`


### 用到了哪些智能指针和 RAII 机制，几种锁的区别是什么？什么是 RAII 资源管理？

RAII 即资源获取就是初始化，利用对象生命周期来控制程序资源，简单来说就是用过局部变量对象来处理一些资源问题

auto_ptr：auto_ptr 则是通过权限转移机制实现，auto_ptr 析构时会删除它所拥有的指针，所以使用时避免多个 auto_ptr 对象管理同一个指针，因为多次删除同一对象会导致未定义行为，
并且一个指针析构，一个指针仍在使用时，会导致空指针访问风险，由于 auto_ptr 内部实现中，析构删除对象
仍然使用 delete 并不是 delete[] 所以 auto_ptr 不能用来管理数组(避免内存泄漏)，auto_ptr 要求对它所拥有的指针完全占有，这一点与引用计数不同，也就是说，一个一般指针不能被两个 auto_ptr 同时
拥有，auto_ptr 对象被拷贝或赋值之后，失去了对原指针的所有权，再次读取操作不安全

**auto_ptr 解决方案**

- 定义赋值运算符，使其进行深复制，这样两个指针将指向不同对象，缺点浪费空间
- 建立所有权，对于特定对象只能是一个指针拥有，这样拥有对象的智能指针的析构函数会删除该对象，然后赋值操操作转移所有权
- 使用引用计数

shared_ptr：shared_ptr 是一个标准的共享所有权的智能指针，允许多指针指向同一对象，shared_ptr 利用引用计数的方式实现了对管理对象所有权的分享，也被称为
引用计数型智能指针，shared_ptr 为了解决 auto_ptr 在对象上所有权上的局限性(auto_ptr 时独占的)，在使用引用计数的机制上提供了可以共享所有权的智能指针，存在额外开销

对于 shared_ptr 使用引用计数实现，在调用 release() 时，当前指针释放资源所有权，引用计数减一，当计数等于 0 时，资源被释放，可使用成员函数 use_count() 查看资源的所有者个数，
在对象进行构造时，引用计数加 1

weak_ptr：shared_ptr 的助手，没有重载 operator* 和 operator->，它的最大作用在于协同 shared_ptr 工作，仅有观测权，
weak_ptr 可以对 shared_ptr 进行引用，但不改变其引用计数，同时失效

unique_ptr：替代不安全的 auto_ptr，它持有对对象的独有权，两个 unique_ptr 不能指向同一对象，无法拷贝、智能移动 unique_ptr 即资源管理权转移，release() 释放对对象的所有权

### 任务队列怎么实现的？除了加锁还有什么实现方式？

条件变量搭配互斥锁、CAS

### 死锁的原因？条件？如何预防？如何避免？如何解除？

原因：系统资源不足；进程运行推进顺序不合适；资源分配不当

条件：互斥；不可剥夺；循环等待；请求与保持

预防：破坏任意一个条件

避免：银行家算法

检测：资源分配图简化

### 怎么进行压测的？

`webbench -t 60 -c 1000 -2 -k 39.107.70.253:20000/`

### 为什么要用非阻塞 IO？
### Reactor 模式是什么？

Reactor 模式可以简单概括为，服务器端为了能流畅处理多个客户端连接，一般在某个进程 A 里面 accept 新的
客户端连接并生成新连接的 socketfd，然后将这些新连接的 socketfd 分发数个工作线程 B1、B2、B3、···，这
些工作线程监听并处理这些新连接上的网络 IO 事件(即收发数据)，同时，还处理系统中的一些事务，这里我们将 A 称为
主线程，B1、B2、B3、···，等称为工作线程，工作线程的代码框架一般如下：

```cpp
while (!m_quit) {
    
    // 负责通过 epoll()/poll()/select() 去检测 socketfd 上的 IO 事件，
    // 若存在这些事件，则下一步 handle_io_events() 来处理这些事件(收发数据)，做完之后可
    // 能还要做一些系统其他任务，即调用 handle_others_things()
    epoll_or_select_func();
    handle_io_events();
    handle_other_things();
}
```

### TCP 收发环形缓冲区怎么实现的？
### 什么是 dameon 进程？dameon 进程创建原理是什么？

Linux daemon 是运行于后台常驻内存的一种特殊进程，周期性的执行或者等待 trigger 执行某个任务，与用户交互断开，独
立于控制终端。 一个守护进程的父进程是 init 进程，它是一个孤儿进程，没有控制终端，所以任何输出，无论是向标
准输出设备 stdout 还是标准出错设备 stderr 的 输出都被丢到了 /dev/null 中。守护进程一般用作服务
器进程，如 httpd，syslogd 等。

**进程、进程组、会话、控制终端之间的关系**

- 进程组：由一个或者多个进程组成，进程组号(GID)，就是这些进程中的进程组长的 PID

- 会话：又叫会话期，它包括了期间所有的进程组，一般一个会话开始于用户 login，一般 login 的是 shell 的终端，所以 shell 是此次 会话的shoul 首进程，会话一般结束于 logout，对于非进程组长，它可以调用 setid() 创建一个新的会话

- 控制终端：一般指 shell 的终端，它在会话期可有可没有

**创建守护进程**

- 首先让其成为后台进程

用 fork 创建进程，父进程退出，子进程称为孤儿进程被 init 进程接管，子进程变为后台进程

- 脱离父进程控制终端，登录会话和进程组

调用 setid() 让子进程称为成为新会话的组长，脱离父进程的会话期，setid() 在调用者是某进程组的组长时
会失败，但是前提保证调用者不是组长即可 之后子进程变为新会话期的组长

- 控制进程重新开启控制终端

因为会话组的组长有权限重新打开控制终端，所以这里第二次 fork 将子进程结束，留着孙进程，孙进程不是会话组的组长所以没有权利再
打开控制终端，这样整个程序就与控制终端隔离了

- 关闭文件描述符

进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误

- 重定向 0，1，2 标准文件描述符

将三个标准文件描述符定向到 /dev/null 中

- 改变工作目录和文件掩码

进程活动时，其工作目录所在的文件系统不能卸下(比如工作目录在一个 NFS 中,运行一个 daemon 会导致 umount 无法成功)。一
般需要将工作目录改变 到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如 chdir("/tmp")，进程从
创建它的父进程那里继承 了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：umask(0);

### nginx 的并发模型是什么？或者说它是如何处理高并发的？
### 你做这个项目的初衷是什么？为什么要做这个项目？

前情提要，之前看过 TinyHttpd 源码，想自己写一个 Web 服务器，由于当时能力有限， 就从去年推到今年的 1 月份，在脑海里有这个项
目之前，我们老师曾经推荐好几本书， 我下去看了看，诸如：《C++ 编程思想》、《C 和指针》、《C++ Primer》、《侯捷 STL 源码剖
析》、《TCP/IP 详解 卷 1》、《高性能服务器编程》、《现代操作系统》、《计算机网络》等，这些书本涵盖了：

- 多线程编程、Socket 编程、泛型编程
- TCP/IP 协议、通信协议
- IO 相关
- 多线程相关同步原语
- dameon 进程创建原理
- 版本控制 git、Makefile、shell、编程规范

做完这个项目刚好可以把握所学的知识在秋招前复习一遍，哈哈哈哈哈哈哈，迫不及待

后续项目中进行重构，采用智能指针代替全裸的指针，借鉴 muduo 思想、林亚 写的项目以及陈帅豪项目，把我的 web.d 重构了一番
