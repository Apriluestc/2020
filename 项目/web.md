# Web

### 介绍以下这个项目

本项目为 C++ 11 编写的高性能 Web 服务器，使用状态机解析了 GET、POST 请求，可静态处理资源，支
持 HTTP 长连接、支持管线化请求，并实现了异步日志，实时记录服务器运行状态，
经 webbench 测试该服务器可达 30000 并发量

### 定时器怎么实现的？还有什么实现方式？
### 实现一个无锁队列

【详见】https://github.com/Apriluestc/2020/blob/master/doc/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95.md#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97

### eventfd 是什么？有什么好处

在 Reactor 模式中，为了能流畅处理多个客户端的连接，通常情况下会有一个主进程和多个工作进程，
主进程负责 accept 新连接并生成新连接的 socketfd，然后再将这些 fd 分发给数个工作进程，其中主线程
向子线程(work_thread)分发 fd 的方式在 Linux 平台上常见的有三种，分别是 pipe、eventfd、socketpair，
跨线程异步唤醒，将生成的 eventfd 绑定到 epoll_fd 上，需要时向这个 eventfd 上写入一个字节，工作线程立即被唤醒，
**eventfd 是 Linux 引入的一种轻量级的 IPC 方式，不同进程可以通过 eventfd 建立起一个共享的计数器，这个计数器由内核维护，
充当信息的角色，与他关联的进程可以进行读写，从整体上来讲，eventfd 更加有优势，仅仅通过一个文件描述符，便实现了读写功能，
而 pipe 和 socketpair 都占用两个 fd**

```cpp
int eventfd(unsigned int initval, int flags);
```

### 异步日志是什么？为什么要这么做？
### 什么是优雅关闭连接？
### Epoll 的边沿触发和水平触发有什么区别？
### Epoll 为什么高效，相较于 select、poll？
### HTTP 报文有哪些字段？
### 加入服务器要升级，又不想让用户感知这个行为，怎么做？

在我们版本运行之初，可以这么理解，已经将完好的版本发布，现在要对其进行升级，但是又不要用
户感知自己的服务器的升级行为，我们可参考 nginx 平滑升级

- nginx 平滑升级

当前服务器正在运行 nginx 服务，现对 nginx 进行升级(且跨度不大，容易造成服务崩溃)且在不停止
服务的情况下进行升级

**具体过程**

- 在不停掉旧进程的情况下，启动新进程
- 就进程负责处理仍然没有处理完的请求，但不接收新请求
- 新进程负责接受请求
- 老进程处理完所有请求，关闭所有连接后，服务终止

### 一个请求到来具体的处理过程是什么样的？
### 线程的唤醒方式还有哪些？
### 怎么检查内存泄漏？
### 用到了哪些智能指针和 RAII 机制，几种锁的区别是什么？
### 任务队列怎么实现的？除了加锁还有什么实现方式？
### 如何解决死锁？
### 怎么进行压测的？
### 为什么要用非阻塞 IO？
### Reactor 模式是什么？

Reactor 模式可以简单概括为，服务器端为了能流畅处理多个客户端连接，一般在某个进程 A 里面 accept 新的
客户端连接并生成新连接的 socketfd，然后将这些新连接的 socketfd 分发数个工作线程 B1、B2、B3、···，这
些工作线程监听并处理这些新连接上的网络 IO 事件(即收发数据)，同时，还处理系统中的一些事务，这里我们将 A 称为
主线程，B1、B2、B3、···，等称为工作线程，工作线程的代码框架一般如下：

```cpp
while (!m_quit) {
    
    // 负责通过 epoll()/poll()/select() 去检测 socketfd 上的 IO 事件，
    // 若存在这些事件，则下一步 handle_io_events() 来处理这些事件(收发数据)，做完之后可
    // 能还要做一些系统其他任务，即调用 handle_others_things()
    epoll_or_select_func();
    handle_io_events();
    handle_other_things();
}
```

### TCP 收发环形缓冲区怎么实现的？
### 什么是 dameon 进程？dameon 进程创建原理是什么？

Linux daemon 是运行于后台常驻内存的一种特殊进程，周期性的执行或者等待 trigger 执行某个任务，与用户交互断开，独
立于控制终端。 一个守护进程的父进程是 init 进程，它是一个孤儿进程，没有控制终端，所以任何输出，无论是向标
准输出设备 stdout 还是标准出错设备 stderr 的 输出都被丢到了 /dev/null 中。守护进程一般用作服务
器进程，如 httpd，syslogd 等。

**进程、进程组、会话、控制终端之间的关系**

- 进程组：由一个或者多个进程组成，进程组号(GID)，就是这些进程中的进程组长的 PID

- 会话：又叫会话期，它包括了期间所有的进程组，一般一个会话开始于用户 login，一般 login 的是 shell 的终端，所以 shell 是此次 会话的shoul 首进程，会话一般结束于 logout，对于非进程组长，它可以调用 setid() 创建一个新的会话

- 控制终端：一般指 shell 的终端，它在会话期可有可没有

**创建守护进程**

- 首先让其成为后台进程

用 fork 创建进程，父进程退出，子进程称为孤儿进程被 init 进程接管，子进程变为后台进程

- 脱离父进程控制终端，登录会话和进程组

调用 setid() 让子进程称为成为新会话的组长，脱离父进程的会话期，setid() 在调用者是某进程组的组长时
会失败，但是前提保证调用者不是组长即可 之后子进程变为新会话期的组长

- 控制进程重新开启控制终端

因为会话组的组长有权限重新打开控制终端，所以这里第二次 fork 将子进程结束，留着孙进程，孙进程不是会话组的组长所以没有权利再
打开控制终端，这样整个程序就与控制终端隔离了

- 关闭文件描述符

进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误

- 重定向 0，1，2 标准文件描述符

将三个标准文件描述符定向到 /dev/null 中

- 改变工作目录和文件掩码

进程活动时，其工作目录所在的文件系统不能卸下(比如工作目录在一个 NFS 中,运行一个 daemon 会导致 umount 无法成功)。一
般需要将工作目录改变 到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如 chdir("/tmp")，进程从
创建它的父进程那里继承 了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：umask(0);

### nginx 的并发模型是什么？或者说它是如何处理高并发的？
### 你做这个项目的初衷是什么？为什么要做这个项目？
